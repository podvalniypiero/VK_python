#Декоратор должен проверять наличие значения в кэше перед вызовом функции. Если значение уже есть в кэше,
# оно должно быть возвращено. Если значения в кэше нет, вызывается сама функция и ее результат сохраняется в кэше.
# Для реализации данного декоратора можно использовать словарь, где ключами будут аргументы функции,
# а значениями – результаты ее выполнения. При каждом вызове функции будет проверяться наличие значения в словаре и,
# если оно есть, оно будет возвращено. Если значения нет, функция будет вызвана и ее результат будет сохранен
# в словаре.


# В данном коде мы определяем декоратор `cache_deco`, который принимает на вход функцию `func`.
# Внутри декоратора создается пустой словарь `cache`, который будет использоваться для хранения вычисленных
# значений. Далее определяется новая функция `wrapper`, которая будет возвращена в качестве результата
# работы декоратора. Функция `wrapper` принимает переменное количество аргументов `*args`, именно эти аргументы
# будут использоваться в качестве ключей для доступа к значениям в кэше. Для проверки наличия значения в кэше
# используется оператор `in`, который проверяет наличие ключа в словаре. Если значение уже есть в кэше,
# оно возвращается, иначе вызывается исходная функция `func` с переданными аргументами `*args`.
# Результат вызова функции сохраняется в кэше с помощью оператора присваивания, где ключом является переданный
# набор аргументов `args`, а значением – результат вычислений. Затем результат возвращается.
# Наконец, декоратор возвращает функцию `wrapper`, которая заменяет исходную функцию `func`.
def cache_deco(func):
    cache = {} # словарь
    def wrapper(*args):
        if args in cache:
            return cache[args]
        else:
            result = func(*args)
            cache[args] = result
            return result

    return wrapper

code = []
while data := input():
    code.append(data)
code = "\n".join(code)
exec(code)
